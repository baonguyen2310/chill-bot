<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Object Detection</title>
    <!-- Add TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- Add COCO-SSD model -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>

    <style>
        h1 {
            color: #22ff00;
        }
        #micButton {
            padding: 10px 20px;
            background-color: #22ff00;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
        }
        #speechFeedback {
            margin: 10px;
            padding: 10px;
            min-height: 30px;
            color: #22ff00;
            font-size: 20px;
        }
    </style>

</head>
<body>
    <div style="position: relative;">
        <video id="video" width="640" height="480" autoplay></video>
        <canvas id="canvas" width="640" height="480" style="position: absolute; left: 0; top: 0;"></canvas>
    </div>
    <button id="micButton">üé§ H·ªèi</button>
    <div id="speechFeedback"></div>

    <script>
        const SPEED = 50;
        const SEND_INTERVAL = 100; // 100ms
        let throttle = 0;
        let steering = 0;
        let lastSendTime = 0;

        // UDP setup through WebRTC
        const socket = new WebSocket('ws://localhost:8080');
        socket.onmessage = (event) => {
            if (event.data.startsWith('V:')) {
                const voltage = parseFloat(event.data.substring(2));
                document.getElementById('voltage').textContent = `Battery: ${voltage.toFixed(2)}V`;
            }
        };

        function sendControl() {
            const now = Date.now();
            if (now - lastSendTime >= SEND_INTERVAL) {
                const command = `1,${Math.round(throttle)},${Math.round(steering)}`;
                socket.send(command);
                lastSendTime = now;
            }
        }

        setInterval(sendControl, 10);

        // Device state management
        const deviceStates = {
            servo: 90,
            fan: false,
            laze: false
        };




        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const micButton = document.getElementById('micButton');
        const speechFeedback = document.getElementById('speechFeedback');
        
        // Add Vietnamese mapping
        const vietnameseLabels = {
            'person': 'con ng∆∞·ªùi',
            'bicycle': 'xe ƒë·∫°p',
            'car': 'xe h∆°i',
            'motorcycle': 'xe m√°y',
            'airplane': 'm√°y bay',
            'bus': 'xe bu√Ωt',
            'train': 't√†u h·ªèa',
            'truck': 'xe t·∫£i',
            'boat': 'thuy·ªÅn',
            'traffic light': 'ƒë√®n giao th√¥ng',
            'fire hydrant': 'v√≤i n∆∞·ªõc ch·ªØa ch√°y',
            'stop sign': 'bi·ªÉn b√°o d·ª´ng',
            'parking meter': 'ƒë·ªìng h·ªì ƒë·ªó xe',
            'bench': 'gh·∫ø d√†i',
            'bird': 'con chim',
            'cat': 'con m√®o',
            'dog': 'con ch√≥',
            'horse': 'con ng·ª±a',
            'sheep': 'con c·ª´u',
            'cow': 'con b√≤',
            'elephant': 'con voi',
            'bear': 'con g·∫•u',
            'zebra': 'ng·ª±a v·∫±n',
            'giraffe': 'h∆∞∆°u cao c·ªï',
            'backpack': 'ba l√¥',
            'umbrella': '√¥ d√π',
            'handbag': 't√∫i x√°ch',
            'tie': 'c√† v·∫°t',
            'suitcase': 'vali',
            'frisbee': 'ƒëƒ©a n√©m',
            'skis': 'v√°n tr∆∞·ª£t tuy·∫øt',
            'snowboard': 'v√°n tr∆∞·ª£t tuy·∫øt',
            'sports ball': 'b√≥ng th·ªÉ thao',
            'kite': 'di·ªÅu',
            'baseball bat': 'g·∫≠y b√≥ng ch√†y',
            'baseball glove': 'gƒÉng tay b√≥ng ch√†y',
            'skateboard': 'v√°n tr∆∞·ª£t',
            'surfboard': 'v√°n l∆∞·ªõt s√≥ng',
            'tennis racket': 'v·ª£t tennis',
            'bottle': 'chai',
            'wine glass': 'ly r∆∞·ª£u',
            'cup': 'c·ªëc',
            'fork': 'nƒ©a',
            'knife': 'dao',
            'spoon': 'th√¨a',
            'bowl': 'b√°t',
            'banana': 'chu·ªëi',
            'apple': 't√°o',
            'sandwich': 'b√°nh m√¨ k·∫πp',
            'orange': 'cam',
            'broccoli': 'b√¥ng c·∫£i xanh',
            'carrot': 'c√† r·ªët',
            'hot dog': 'x√∫c x√≠ch',
            'pizza': 'pizza',
            'donut': 'b√°nh r√°n',
            'cake': 'b√°nh ng·ªçt',
            'chair': 'gh·∫ø',
            'couch': 'gh·∫ø sofa',
            'potted plant': 'c√¢y c·∫£nh',
            'bed': 'gi∆∞·ªùng',
            'dining table': 'b√†n ƒÉn',
            'toilet': 'nh√† v·ªá sinh',
            'tv': 'ti vi',
            'laptop': 'm√°y t√≠nh x√°ch tay',
            'mouse': 'chu·ªôt m√°y t√≠nh',
            'remote': 'ƒëi·ªÅu khi·ªÉn',
            'keyboard': 'b√†n ph√≠m',
            'cell phone': 'ƒëi·ªán tho·∫°i',
            'microwave': 'l√≤ vi s√≥ng',
            'oven': 'l√≤ n∆∞·ªõng',
            'toaster': 'm√°y n∆∞·ªõng b√°nh m√¨',
            'sink': 'b·ªìn r·ª≠a',
            'refrigerator': 't·ªß l·∫°nh',
            'book': 's√°ch',
            'clock': 'ƒë·ªìng h·ªì',
            'vase': 'b√¨nh hoa',
            'scissors': 'k√©o',
            'teddy bear': 'g·∫•u b√¥ng',
            'hair drier': 'm√°y s·∫•y t√≥c',
            'toothbrush': 'b√†n ch·∫£i ƒë√°nh rƒÉng'
        };

        let currentPredictions = [];

        // Speech Recognition setup
        const recognition = new webkitSpeechRecognition();
        recognition.lang = 'vi-VN';
        recognition.continuous = false;
        recognition.interimResults = false;

        micButton.addEventListener('click', () => {
            recognition.start();
        });

        recognition.onstart = () => {
            speechFeedback.textContent = "ƒêang nghe...";
            micButton.disabled = true;
        };

        recognition.onend = () => {
            micButton.disabled = false;
            setTimeout(() => {
                speechFeedback.textContent = "";
            }, 2000);
        };

        recognition.onresult = (event) => {
            const question = event.results[0][0].transcript.toLowerCase();
            speechFeedback.textContent = event.results[0][0].transcript;
            if (question.startsWith('ƒë√¢y l√†')) {
                const searchTerm = question.replace('ƒë√¢y l√†', '').replace('ƒë√∫ng kh√¥ng', '').trim();
                checkObject(searchTerm);
            }
        };

        recognition.onaudiostart = () => {
            speechFeedback.textContent = "ƒêang nghe...";
        };

        recognition.onspeechstart = () => {
            speechFeedback.textContent = "ƒêang nh·∫≠n di·ªán...";
        };

        recognition.onerror = (event) => {
            speechFeedback.textContent = "L·ªói: " + event.error;
            micButton.disabled = false;
        };

        function checkObject(searchTerm) {
            const speech = new SpeechSynthesisUtterance();
            speech.lang = 'vi-VN';

            // Convert English labels to Vietnamese for comparison
            const foundObject = currentPredictions.some(pred => 
                vietnameseLabels[pred.class]?.toLowerCase() === searchTerm.toLowerCase() &&
                pred.score >= 0.7
            );

            speech.text = foundObject ? 
                `Ph·∫£i, T√¥i th·∫•y ${searchTerm} trong camera v·ªõi ƒë·ªô ch√≠nh x√°c l√† ${Math.round(currentPredictions.find(pred => vietnameseLabels[pred.class]?.toLowerCase() === searchTerm.toLowerCase()).score * 100)}%` : 
                `Kh√¥ng, T√¥i kh√¥ng th·∫•y ${searchTerm} n√†o trong camera`;

            window.speechSynthesis.speak(speech);

            if (foundObject) {
                // Create nodding sequence (up-down-up-down)
                const nodSequence = [
                    { angle: 0, duration: 100 },
                    { angle: 180, duration: 100 },
                    { angle: 0, duration: 100 },
                    { angle: 180, duration: 100 },
                    { angle: 90, duration: 100 }  // Return to center position
                ];

                let time = 0;
                nodSequence.forEach(move => {
                    setTimeout(() => {
                        deviceStates.servo = move.angle;
                        socket.send(`ESP2:SERVO2:${move.angle}`);
                        console.log(`ESP2:SERVO2:${move.angle}`);
                    }, time);
                    time += move.duration;
                });
            }
            else {
                // Implement head shaking movement (left-right-left-right)
                const shakeSequence = [
                    { steering: SPEED, duration: 200 },
                    { steering: -SPEED, duration: 200 },
                    { steering: SPEED, duration: 200 },
                    { steering: -SPEED, duration: 200 },
                    { steering: 0, duration: 0 }
                ];

                let time = 0;
                shakeSequence.forEach(move => {
                    setTimeout(() => {
                        steering = move.steering;
                    }, time);
                    time += move.duration;
                });
            }
        }

        // Load camera
        if (navigator.mediaDevices.getUserMedia) {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(function (stream) {
                    video.srcObject = stream;
                })
                .catch(function (error) {
                    console.log("Camera error: ", error);
                });
        }

        async function loadObjectDetector() {
            try {
                objectDetector = await cocoSsd.load();
                console.log('COCO-SSD Model loaded');
            } catch (error) {
                console.error('Error loading COCO-SSD model:', error);
            }
        }

        // Load model khi trang ƒë∆∞·ª£c load
        loadObjectDetector();

        // Load COCO-SSD model
        cocoSsd.load().then(model => {
            // Detect objects every frame
            setInterval(() => {
                model.detect(video).then(predictions => {
                    // Update current predictions
                    currentPredictions = predictions;

                    // Clear canvas
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Draw predictions with confidence > 70%
                    predictions.forEach(prediction => {
                        if (prediction.score >= 0.7) {
                            context.beginPath();
                            context.strokeStyle = "#22ff00";
                            context.lineWidth = 5;
                            context.rect(
                                prediction.bbox[0],
                                prediction.bbox[1],
                                prediction.bbox[2],
                                prediction.bbox[3]
                            );
                            context.stroke();

                            // Draw label with Vietnamese translation if available
                            const label = vietnameseLabels[prediction.class] || prediction.class;
                            context.fillStyle = "#22ff00";
                            context.font = "30px Arial";
                            context.fillText(
                                `${label} ${Math.round(prediction.score * 100)}%`,
                                prediction.bbox[0],
                                prediction.bbox[1] > 10 ? prediction.bbox[1] - 5 : 10
                            );
                        }
                    });
                });
            }, 100); // Detect every 100ms
        });
    </script>
</body>
</html>